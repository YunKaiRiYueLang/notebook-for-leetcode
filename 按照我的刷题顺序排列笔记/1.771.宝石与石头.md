# 771.宝石与石头,C++

## 解法一: 两层循环,线性搜索

作为新手的我最开始想到的办法.
使用

 ```c++

for(auto a1:J)
{
    for(auto a2:S)
    {
        if(a1==a2)
        xxxx
    }
}
```

双层遍历,很蠢的办法
时间复杂度`O(J.length()*S.length())`    空间复杂度`O(1)`;

因为两层for循环的关系,时间复杂度不理想. ***数据结构老师让我们看到两层循环,就要有意识*去优**化他.  
**即便是写双层循环,也是有更好的写法的.应该把J的循环放在里面. 找到宝石,数量加一,然后`break`,可以少比较几次.**

## 解法二: 用哈希高效完成

```c++
unordered_map<char,bool> mp;
int ret=0;
for(auto a1:J)
{
    mp[a1]=1;
}
for(auto a2:S)
{
    if(mp[a2])  ret++;
}
return ret;

```

显然时间复杂度明显降低,为`O(J.length()+S.length())`,空间复杂度提升为`O(J.length(1))`;

像这种在,一个大范围,一个小范围,差找大范围里是不是有小范围的里的东西.都可以用哈希表,将双层遍历变为两次遍历,大幅降低时间复杂度.而代价是增加点空间消耗.  

## 涉及知识点

1. `for` 循环用法. c++基础
2. `for` 搭配`auto`  
3. `string` 容器特性
4. `unordered_map`用法 与哈希表.

-------------------

## 详细说明

1. 明确其基本使用方法.

2. 细节解释
第二种解法的核心是`unordered_map`,用它避开循环嵌套,把乘法关系变为加法关系.  他是**c++11新定义的四个无序关联容器之一**,内部是用哈希函数和关键字类型`==`来实现的.(没错,,与`map`不同,不是使用比较运算符来组织元素). 相对于`map`对面较多数据.在不要求有序的情况下.可以尽量使用 `unordered_map`,以获得插入删除上较高的效率.**在查找问题中.这个容器经常出现**

可以直接定义关键字是**内置类型,string或智能指针的无序容器**.  标准库为内置类型(包括指针),提供了hash模板.标准库类型string 和智能指针类型对应的hash也定义了. 当关键字类型为自定义类型时,必须重载函数.写自己的hash版本.



范围 `for`循环,也是c++ 11 加入的.auto 自动推导类型. 范围`for`循环定位引用时  

而`string`类几乎是`c++`中最常用的容器了.除了具有容器通用特性.它还有一些自己的函数.方便操作字符串.  
