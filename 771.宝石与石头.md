# 771.宝石与石头,C++

## 解法一: 两层循环,线性搜索

作为新手的我最开始想到的办法.
使用

 ```c++

for(auto a1:J)
{
    for(auto a2:S)
    {
        if(a1==a2)
        xxxx
    }
}
```

双层遍历,很蠢的办法
时间复杂度`O(J.length()*S.length())`    空间复杂度`O(1)`;

因为两层for循环的关系,时间复杂度不理想. ***数据结构老师让我们看到两层循环,就要有意识*去优**化他.  
**即便是写双层循环,也是有更好的写法的.应该把J的循环放在里面. 找到宝石,数量加一,然后`break`,可以少比较几次.**

## 解法二: 用哈希高效完成

```c++
unordered_map<char,bool> mp;
int ret=0;
for(auto a1:J)
{
    mp[a1]=1;
}
for(auto a2:S)
{
    if(mp[a2])  ret++;
}
return ret;

```

显然时间复杂度明显降低,为`O(J.length()+S.length())`,空间复杂度提升为`O(J.length(1))`;

像这种在,一个大范围,一个小范围,差找大范围里是不是有小范围的里的东西.都可以用哈希表,将双层遍历变为两次遍历,大幅降低时间复杂度.而代价是增加点空间消耗.  

## 涉及知识点

1. `for` 循环用法. c++基础
2. `for` 搭配`auto`  
3. `string` 容器特性
4. `unordered_map`用法 与哈希表.

-------------------

## 详细说明

第二种解法的核心是`unordered_map`,用它避开循环嵌套,把乘法关系变为加法关系.  他是**c++11加入的四个无序容器之一**,内部是用hash表来实现的.(没错,,与`map`不同,不是使用比较运算符来组织元素)  
